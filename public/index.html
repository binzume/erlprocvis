<!DOCTYPE html>
<html><body>
	<script src="js/utils.js"></script>
	<script src="js/lightgl.js"></script>
	<script id="vs" type="x-shader/x-vertex">
	varying vec2 coord;
	varying float depth;
	void main() {
	coord = gl_TexCoord.xy;
		gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
		depth = gl_Position.z;
	}
	</script>
	
	<script id="fs" type="x-shader/x-fragment">
	uniform sampler2D texture;
	varying vec2 coord;
	varying float depth;
	void main() {
		float r;
		if (depth > 16.0) {
			r = 1.0 / (1.0 + (depth - 16.0) * 0.1);
		} else {
			r = 1.0;
		}
		gl_FragColor = texture2D(texture, coord) * vec4(0.5, 1.0, 1.0, 1.0) * r;
	}
	</script>

  <script>

var size = 20;
var nodes = [];
var edges = [];
var procidx = {};

function circleText(ctx, str, cx, cy, r, st) {
	ctx.save();
	ctx.translate(cx, cy);
	ctx.rotate(st);
	for (var p=0; p<str.length; p++) {
		ctx.fillText(str[p], 0, -r);
		ctx.rotate(ctx.measureText(str[p]).width / r);
	}
	ctx.restore();
}

function proc_loaded(result) {
	if (result == null || result.status != 'ok') {
		console.log("proc_loaded status:" + result.status);
		return;
	}
	nodes = [];
	edges = [];
	procs = result.procs

	for (var i=0; i<procs.length; i++) {
		var proc = procs[i];
		if (!proc.alive) continue;
		procidx[proc.name] = nodes.length;
		nodes.push({type: "proc", name: proc.name, proc: proc, weight: 1.0, links: []});
	}
	
	for (var i=0; i<procs.length; i++) {
		var proc = procs[i];
		if (!proc.alive) continue;
		for (var j=0; j<proc.links.length; j++) {
			var l = proc.links[j];
			if (proc.name < l) {
				console.log("link: " + proc.name + " <-> " + l);
				if (procidx[l]!=null && procidx[proc.name]!=null) {
					edges.push({from: procidx[proc.name], to: procidx[l], weight: 1.0, type: "link"});
					nodes[procidx[proc.name]].links.push(l);
					nodes[procidx[l]].links.push(proc.name);
				}
				
			}
		}
	
		for (var j=0; j<proc.monitors.length; j++) {
			var l = proc.monitors[j];
			console.log("monitor: " + proc.name + " -> " + l);
			if (procidx[l]!=null && procidx[proc.name]!=null) {
				edges.push({from: procidx[proc.name], to: procidx[l], weight: 1.0, type: "monitor"});
			}
		}
	}

	// init nodes
	for (var i=0; i<nodes.length; i++) {
		var node = nodes[i];
		node.edges = [];
		node.x = Math.random() * size - size/2;
		node.y = Math.random() * size - size/2;
		node.z = Math.random() * size - size/2;
		node.v = [0,0,0];
		node.rot = Math.random() * 360;
	
		var canvas = document.createElement("canvas");
		canvas.width  = 512;
		canvas.height = 512;
		node.canvas = canvas;
	
		var ctx = canvas.getContext("2d");
		ctx.clearRect(0, 0, 512, 512);
	
		ctx.font = "40px monospace";
		ctx.textAlign = "center";
		ctx.textBaseline = "middle";
		ctx.fillStyle = "white";
		circleText(ctx, node.name, 256, 256, 160, 0);
		circleText(ctx, node.proc.init_module || "", 256, 256, 190, Math.PI * 0.3);
		
		node.tex = GL.Texture.fromImage(canvas, {});
	}
	
	for (var i=0; i<edges.length; i++) {
		var edge = edges[i];
		nodes[edge.from].edges.push(edge);
	}

	adjust_pos(20);

}

function adjust_pos(n) {
	// position
	for (var k=0; k<n; k++) {
		for (var i=0; i<nodes.length; i++) {
			var node = nodes[i];
			var f = [0.0,0.0,0.0];
			
			var dd = node.x*node.x + node.y*node.y + node.z*node.z;
			if (dd > 2.0) {
				f[0] += -node.x * 0.1 / dd;
				f[1] += -node.y * 0.1 / dd;
				f[2] += -node.z * 0.1 / dd;
			}
	
			for (var j=0; j<nodes.length; j++) {
				if (j == i) continue;
				var node2 = nodes[j];
				var d = [node.x - node2.x, node.y - node2.y, node.z - node2.z];
				var dd = d[0]*d[0] + d[1]*d[1] + d[2]*d[2] + 0.01;
				var dn = Math.sqrt(dd);
				var st = node.weight * node2.weight / dd * 0.2;
				f[0] += d[0] / dn * st;
				f[1] += d[1] / dn * st;
				f[2] += d[2] / dn * st;
			}
			for (var j=0; j<node.links.length; j++) {
				var idx = procidx[node.links[j]];
				if (idx == null || idx == i) continue;
				var node2 = nodes[idx];
				var d = [node.x - node2.x, node.y - node2.y, node.z - node2.z];
				var dn = Math.sqrt(d[0]*d[0] + d[1]*d[1] + d[2]*d[2]);
				var l = 1.0;
				var sk = 0.2 / Math.sqrt(node.links.length + node2.links.length);
				f[0] -= d[0] / dn * (dn-l) * sk;
				f[1] -= d[1] / dn * (dn-l) * sk;
				f[2] -= d[2] / dn * (dn-l) * sk;
			}
			node.v[0] *= 0.6;
			node.v[1] *= 0.6;
			node.v[2] *= 0.6;
			node.v[0] = f[0];
			node.v[1] = f[1];
			node.v[2] = f[2];
		}
		for (var i=0; i<nodes.length; i++) {
			var node = nodes[i];
			node.x += node.v[0];
			node.y += node.v[1];
			node.z += node.v[2];
		}
	}

	linklines.vertices = [];
	linklines.coords = [];
	linklines.lines = [];
	for (var i=0; i<edges.length; i++) {
		var edge = edges[i];
		var from = nodes[edge.from];
		var to = nodes[edge.to];
		var d = edge.type == "link" ? 0 : 0.5;
		linklines.vertices.push([from.x, from.y, from.z], [to.x, to.y, to.z]);
		linklines.coords.push([0,d], [1,d]);
		linklines.lines.push([i*2, i*2+1]);
	}
	linklines.compile();
}

var gl = GL.create();
var linklines = new GL.Mesh({ coords: true, lines: true });

var angleX = 20;
var angleY = 20;
var posX = 0;
var posY = 0;
var posZ = -20;
var rot = 0;

var mesh = GL.Mesh.plane({coords: true});

var vs = document.getElementById("vs").textContent;
var fs = document.getElementById("fs").textContent;
var shader = new GL.Shader(vs, fs);

var tex01 = GL.Texture.fromURL('images/node_circle.png');
var tex02 = GL.Texture.fromURL('images/link_tex.png');

gl.canvas.addEventListener('contextmenu', function(e){
		e.preventDefault();
});

gl.onupdate = function(seconds) {
   rot += 45 * seconds;
   adjust_pos(1);
};

gl.ondraw = function() {
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);
  gl.enable( gl.BLEND );
  gl.loadIdentity();
  gl.translate(posX, posY, posZ);
  gl.rotate(30, 1, 0, 0);
  gl.rotate(angleX, 1, 0, 0);
  gl.rotate(angleY, 0, 1, 0);

	for (var i=0; i<nodes.length; i++) {
		var node = nodes[i];
		gl.pushMatrix();

		gl.translate(node.x, node.y, node.z);

		// billboard
		gl.rotate(-angleY, 0, 1, 0);
		gl.rotate(-angleX, 1, 0, 0);

		tex01.bind(0);
		gl.rotate(rot  + node.rot, 0, 0, 1);
		shader.uniforms({
			texture: 0
		}).draw(mesh);

		gl.pushMatrix();
		gl.scale(0.94, 0.94, 0.94);
		gl.rotate(-rot*1.6 + node.rot * 3, 0, 0, 1);
		shader.draw(mesh);
		gl.popMatrix();


		node.tex.bind(0);
		shader.draw(mesh);



		gl.popMatrix();
	}
	
	if (linklines.lines.length > 0) {
		tex02.bind(0);
		gl.lineWidth(2);
		shader.uniforms({
			texture: 0
		}).draw(linklines,gl.LINES);
	}

};


var button = 0;
gl.onmousedown = function(e) {
  e.preventDefault();
  button = e.button;
}

gl.onmousemove = function(e) {
  if (e.dragging) {
    if (button == 2) {
	    posZ += e.deltaY * 0.1;
    } else if (button == 1) {
	    posX += e.deltaX * 0.1;
	    posY -= e.deltaY * 0.1;
    } else {
	    angleY += e.deltaX * 0.5;
	    angleX = Math.max(-90, Math.min(90, angleX + e.deltaY * 0.5));
	}
  }
};


gl.fullscreen();
gl.animate();

getJson("/procs", proc_loaded);


  </script>


</body></html>
